Our malloc program was implemented using a linked list to store the pointers for easy access

The way the address locations are computed follow this model.
Let us have a basic list of pointer objects that hold the size and array index as integers
and the memory address as a pointer as shown below.

The index of Node B is computed to be B.index=A.index+A.size
The index of Node C is computed to be C.index=B.index+B.size
and so on and so forth.

The address field is computed to be A.address = &mainMem[A.index] and we return A.address

          Head----->A----->B----->C----->NULL
intSize             1      5      4     
intIndex            0      1      6
*Address            HEX    HEX    HEX


To satisfy the criteria for first free fit algorithm, we must check whether there exists
a sufficient amount of "memory" between our nodes that would allow us to malloc that region
for a certain size.  To do this we simply have to compare the requested malloc size with the
difference of a subtraction operation between the current node index and the previous node index
plus the previous node size.  For example, let us assume that
we freed Node B such that our list looks like this:

          Head----->A------------>C----->NULL
intSize             1             4     
intIndex            0             6
*Address            HEX           HEX

Now let us assume that we want to malloc a region of memSize = 3.  We iterate through our list with
two placeholder nodes, when we get to A and C we check whether (C.index-[A.index+A.size])>=memSize.
The difference from this operation informs us of how much memory is available to be allocated in
that region.

When we need to free a pointer we simply iterate through our list and compare the pointer with
the address field of the node we are currently at and if they are equivalent we set the previous
node equal to the current.next node.
